---
ms.openlocfilehash: b505f4a4f7a8f50a6044d01a327eef76a7b1ce3b
ms.sourcegitcommit: b0ea451e18504e6267b896732dd26df64ddfa843
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 04/13/2020
ms.locfileid: "70758038"
---
|Propriedade|Descrição|Opções|
|--- |--- |--- |
|`abi.type`|**Tipo de ABI** &ndash; especifica o tipo de ABI (interface binária de aplicativo) do dispositivo emulado. A opção **x86** é para o conjunto de instruções normalmente chamado de "x86" ou "IA-32". A opção **x86_64** é para o conjunto de instruções x86 de 64 bits. A opção **armeabi-v7a** é para o conjunto de instruções ARM com extensões ARM v7-a. A opção **arm64-v8a** é para o conjunto de instruções ARM que oferece suporte a AArch64.|x86, x86_64, armeabi-v7a, arm64-v8a|
|`disk.cachePartition`|**Partição de cache** &ndash; determina se o dispositivo emulado usará uma partição de **/cache** no dispositivo. A partição de **/cache** (que inicialmente é vazia) é o local em que o Android armazena os dados acessados com frequência e os componentes de aplicativo. Se definida como **não**, o emulador não usará uma partição de **/cache**, e as outras configurações de `disk.cache` serão ignoradas.|sim, não|
|`disk.cachePartition.path`|**Caminho da partição de cache** &ndash; especifica um arquivo de imagem de partição de cache no computador de desenvolvimento. O emulador usará esse arquivo para a partição de **/cache**. Insira um caminho absoluto ou um caminho relativo ao diretório de dados do emulador. Se não estiver definido, o emulador criará um arquivo temporário vazio chamado **cache.img** no computador de desenvolvimento. Se o arquivo não existir, será criado como um arquivo vazio. Essa opção será ignorada se `disk.cachePartition` estiver definido como **não**.||
|`disk.cachePartition.size`|**Tamanho da partição de cache** &ndash; o tamanho do arquivo de partição de cache (em bytes). Normalmente, não é necessário definir essa opção, a menos que o aplicativo baixe arquivos muito grandes, maiores que o tamanho padrão do cache, de 66 megabytes. Essa opção será ignorada se `disk.cachePartition` estiver definido como **não**. Se o valor for um inteiro, ele especificará o tamanho em bytes. Também é possível especificar o tamanho em quilobytes, megabytes e gigabytes acrescentando **K**, **M** ou **G** ao valor. O tamanho mínimo é **de 9M** e o tamanho máximo é **1023G**.||
|`disk.dataPartition.initPath`|**Caminho inicial para a partição de dados** &ndash; especifica o conteúdo inicial da partição de dados. Depois de apagar os dados do usuário, o emulador copia o conteúdo do arquivo especificado para os dados do usuário (por padrão, **userdata-qemu.img**) em vez de usar **userdata.img** como versão inicial.||
|`disk.dataPartition.path`|**Caminho para a partição de dados** &ndash; especifica o arquivo de partição de dados de usuário. Para configurar um arquivo de dados de usuário persistente, insira um nome de arquivo e um caminho no computador de desenvolvimento. Se o arquivo não existir, o emulador criará uma imagem do arquivo padrão **userdata.img**, armazena ela no nome de arquivo especificado por `disk.dataPartition.path` e persiste os dados de usuário quando o emulador é desligado. Se um caminho não for especificado, o arquivo padrão será nomeado **userdata-qemu.img**. A ** \<temperatura de** valor especial>faz com que o emulador crie e use um arquivo temporário. Se `disk.dataPartition.initPath` estiver definido, seu conteúdo será copiado para o arquivo `disk.dataPartition.path` no momento da inicialização. Observe que essa opção não pode ser deixada em branco.||
|`disk.dataPartition.size`|**Tamanho da partição de dados** &ndash; especifica o tamanho da partição de dados do usuário em bytes. Se o valor for um inteiro, ele especificará o tamanho em bytes. Também é possível especificar o tamanho em quilobytes, megabytes e gigabytes acrescentando **K**, **M** ou **G** ao valor. O tamanho mínimo é **de 9M** e o tamanho máximo é **1023G**.||
|`disk.ramdisk.path`|**Caminho do ramdisk** &ndash; caminho para a imagem da partição de inicialização (ramdisk). A imagem do ramdisk é um subconjunto da imagem do sistema carregada pelo kernel antes de a imagem do sistema ser montada. A imagem do ramdisk normalmente contém binários de tempo de inicialização e scripts de inicialização. Se essa opção não estiver especificada, o padrão será **ramdisk.img** no diretório do sistema do emulador.||
|`disk.snapStorage.path`|**Caminho de armazenamento de instantâneo** &ndash; caminho para o arquivo de armazenamento de instantâneo em que todos os instantâneos são armazenados. Todos os instantâneos feitos durante a execução serão salvos nesse arquivo. Somente os instantâneos salvos neste arquivo podem ser restaurados durante a execução do emulador. Se essa opção não estiver especificada, o padrão será snapshots.img no diretório de dados do emulador.||
|`disk.systemPartition.initPath`|**Caminho de inicialização da partição do sistema** &ndash; caminho para a cópia somente leitura do arquivo de imagem do sistema; especificamente, a partição que contém as bibliotecas e dados do sistema correspondentes ao nível da API e a qualquer variante. Se esse caminho não estiver especificado, o padrão será system.img no diretório do sistema do emulador.||
|`disk.systemPartition.path`|**Caminho da partição do sistema** &ndash; caminho para a imagem de partição do sistema de leitura/gravação. Se esse caminho não estiver definido, um arquivo temporário será criado e inicializado nos conteúdos do arquivo especificado por `disk.systemPartition.initPath`.||
|`disk.systemPartition.size`|**Tamanho da partição do sistema** &ndash; o tamanho ideal da partição do sistema (em bytes). O tamanho será ignorado se a imagem da partição do sistema real for maior que essa configuração. Caso contrário, especifica o tamanho máximo que o arquivo de partição do sistema pode atingir. Se o valor for um inteiro, ele especificará o tamanho em bytes. Também é possível especificar o tamanho em quilobytes, megabytes e gigabytes acrescentando **K**, **M** ou **G** ao valor. O tamanho mínimo é **de 9M** e o tamanho máximo é **1023G**.||
|`hw.accelerometer`|**Acelerômetro** &ndash; determina se o dispositivo emulado contém um sensor de acelerômetro. O acelerômetro ajuda o dispositivo a determinar orientação (usada para rotação automática). O acelerômetro informa a aceleração do dispositivo em três eixos do sensor.|sim, não|
|`hw.audioInput`|**Suporte para gravação de áudio** &ndash; determina se o dispositivo emulado pode gravar áudio.|sim, não|
|`hw.audioOutput`|**Suporte para reprodução de áudio** &ndash; determina se o dispositivo emulado pode reproduzir áudio.|sim, não|
|`hw.battery`|**Suporte para bateria** &ndash; determina se o dispositivo emulado pode ser executado em uma bateria.|sim, não|
|`hw.camera`|**Suporte para câmera** &ndash; determina se o dispositivo emulado tem uma câmera.|sim, não|
|`hw.camera.back`|**Câmera traseira** &ndash; configura a câmera traseira (a lente fica em direção contrária ao usuário). Caso esteja usando uma webcam no computador de desenvolvimento para simular uma câmera traseira no dispositivo emulado, esse valor deve ser definido como webcam*n*, em que _n_ seleciona a webcam (se você tiver apenas uma webcam, escolha **webcam0**). Se definido como emulado, o emulador simulará a câmera no software. Para desabilitar a câmera traseira, defina esse valor como nenhum. Ao habilitar a câmera traseira, lembre-se de habilitar `hw.camera` também.|emulado, nenhum, webcam0|
|`hw.camera.front`|**Câmera frontal** &ndash; configura a câmera frontal (a lente fica de frente para o usuário). Caso esteja usando uma webcam no computador de desenvolvimento para simular uma câmera frontal no dispositivo emulado, esse valor deve ser definido como webcam*n*, em que _n_ seleciona a webcam (se você tiver apenas uma webcam, escolha **webcam0**). Se definido como emulado, o emulador simulará uma câmera no software. Para desabilitar a câmera frontal, defina esse valor como nenhum. Ao habilitar a câmera frontal, lembre-se de habilitar `hw.camera` também.|emulado, nenhum, webcam0|
|`hw.camera.maxHorizontalPixels`|**Máximo de pixels da câmera na horizontal** &ndash; configura a resolução máxima na horizontal da câmera do dispositivo emulado (em pixels).||
|`hw.camera.maxVerticalPixels`|**Máximo de pixels da câmera na vertical** &ndash; configura a resolução máxima na vertical da câmera do dispositivo emulado (em pixels).||
|`hw.cpu.arch`|**Arquitetura da CPU** &ndash; a arquitetura da CPU a ser emulada pelo dispositivo virtual. Se estiver usando o Intel HAXM para aceleração de hardware, selecione **x86** para uma CPU de 32 bits. Selecione **x86_64** para um dispositivo de 64 bits acelerado por HAXM. (Certifique-se de instalar a imagem correspondente do sistema Intel x86 no SDK Manager: por exemplo, Intel x86 Atom ou Intel x86 Atom_64.) Para simular uma CPU ARM, selecione **o braço** para 32 bits ou selecione **arm64** para uma CPU ARM de 64 bits. Lembre-se que dispositivos virtuais baseados em ARM serão executados de forma muito mais lenta que aqueles baseados em x86, porque a aceleração de hardware não está disponível para ARM.|x86, x86_64, arm, arm64|
|`hw.cpu.model`|**Modelo de CPU** &ndash; esse valor normalmente não é definido (será definido como um valor derivado de `hw.cpu.arch` se não for explicitamente definido). No entanto, pode ser definido como uma cadeia de caracteres específicas do emulador para uso experimental.||
|`hw.dPad`|**Chaves DPad** &ndash; determina se o dispositivo emulado dá suporte a chaves de botão direcional (DPad). Normalmente, um DPad tem quatro chaves para indicar o controle direcional.|sim, não|
|`hw.gps`|**Suporte para GPS** &ndash; determina se o dispositivo emulado tem um receptor GPS.|sim, não|
|`hw.gpu.enabled`|**Emulação de GPU** &ndash; determina se o dispositivo emulado dá suporte à emulação de GPU. Quando habilitada, a emulação de GPU usa o Open GL para Embedded Systems (OpenGL ES) para renderizar gráficos 2D e 3D na tela e a configuração do Modo de Emulação de GPU associada determina como a emulação de GPU é implementada.|sim, não|
|`hw.gpu.mode`|**Modo de emulação de GPU** &ndash; determina como a emulação de GPU é implementada pelo emulador. Se você selecionar automático, o emulador escolherá a aceleração de hardware e software com base na configuração do computador de desenvolvimento. Se você selecionar host, o emulador usará o processador de gráfico do seu computador de desenvolvimento para executar a emulação de GPU e renderizar mais rápido. Se sua GPU não é compatível com o emulador e você estiver no Windows, é possível tentar ângulo em vez de host. O modo ângulo usa o DirectX para proporcionar um desempenho semelhante ao host. Se você selecionar mesa, o emulador usará a biblioteca de software 3D Mesa para renderizar elementos gráficos. Selecione mesa se tiver problemas de renderização por meio do processador de gráfico do computador de desenvolvimento. O modo swiftshader pode ser usado para renderizar elementos gráficos no software com desempenho ligeiramente menor que por meio da GPU do computador. Off (desabilitar emulação de hardware de gráficos) é uma opção preterida que pode causar a renderização inadequada de alguns itens e, portanto, não é recomendada.|automático, host, mesa, ângulo, swiftshader, off|
|`hw.gsmModem`|**Suporte para modem GSM** &ndash; determina se o dispositivo emulado inclui um modem que oferece suporte ao sistema de telefonia móvel GSM (Sistema Global para Comunicações Móveis).|sim, não|
|`hw.initialOrientation`|**Orientação da tela de inicial** &ndash; configura a orientação inicial da tela no dispositivo emulado (modo retrato ou paisagem). No modo retrato, a tela é mais alta do que larga. No modo paisagem, a tela é mais larga do que alta. Ao executar o dispositivo emulado, é possível alterar a orientação se os modos retrato e paisagem tiverem suporte no perfil do dispositivo.|retrato, paisagem|
|`hw.keyboard`|**Suporte para teclado** &ndash; determina se o dispositivo emulado dá suporte a um teclado QWERTY.|sim, não|
|`hw.keyboard.charmap`|**Nome do charmap do teclado** &ndash; o nome do charmap do hardware do dispositivo. OBSERVAÇÃO: esse sempre deve ser o padrão **qwerty2**, a menos que você tenha modificado a imagem do sistema adequadamente. Esse nome é enviado para o kernel no momento da inicialização. Usar um nome incorreto resulta em um dispositivo virtual inutilizável.||
|`hw.keyboard.lid`|**Suporte para a tampa de teclado** &ndash; se o suporte para teclado estiver habilitado, essa configuração determina se o teclado QWERTY pode ser fechado/oculto ou aberto/visível. Essa configuração será ignorada se hw.keyboard estiver definido como false. OBSERVAÇÃO: o valor padrão será false se o dispositivo emulado tiver como alvo o nível da API 12 ou superior.|sim, não|
|`hw.lcd.backlight`|**Luz de fundo LCD** &ndash; determina se uma luz de fundo LCD é simulada pelo dispositivo emulado.|sim, não|
|`hw.lcd.density`|**Densidade de LCD** &ndash; a densidade da tela de LCD emulada, medida em pixels independentes de densidade ou dp (dp é uma unidade virtual de pixel). Quando a configuração é de 160 dp, cada dp corresponde a um pixel físico. Em runtime, o Android usa esse valor para selecionar e dimensionar os recursos/ativos apropriados para a renderização correta da exibição.|120, 160, 240, 213, 320|
|`hw.lcd.depth`|**Profundidade da cor do LCD** &ndash; a profundidade de bit de cor do framebuffer emulado que contém o bitmap para controlar a tela de LCD. Esse valor pode ser 16 bits (65.536 cores possíveis) ou 32 bits (16.777.216 cores e transparência). A configuração de 32 bits pode fazer o emulador ser executado a um ritmo um pouco mais lento, mas com maior precisão de cor.|16, 32|
|`hw.lcd.height`|**Altura de pixel do LCD** &ndash; o número de pixels que compõem a dimensão vertical da tela de LCD emulada.||
|`hw.lcd.width`|**Largura de pixel do LCD** &ndash; o número de pixels que compõem a dimensão horizontal da tela de LCD emulada.||
|`hw.mainKeys`|**Teclas Voltar/Tela Inicial do hardware** &ndash; determinam se o dispositivo emulado oferece suporte aos botões de navegação Voltar e Tela Inicial do hardware. Esse valor poderá ser definido como **sim** se os botões forem implementados somente no software. Caso `hw.mainKeys` seja definido como **sim**, o emulador não exibirá botões de navegação na tela, mas é possível usar o painel lateral do emulador para "pressionar" esses botões.|sim, não|
|`hw.ramSize`|**Tamanho da RAM do dispositivo** &ndash; a quantidade de RAM física do dispositivo emulado, em megabytes. O valor padrão será calculado com base no tamanho da tela ou na versão de capa. Aumentar o tamanho pode acelerar a operação do emulador, mas exige mais recursos do computador de desenvolvimento.||
|`hw.screen`|**Tipo de tela touch** &ndash; define o tipo de tela no dispositivo emulado. Uma tela multitouch pode acompanhar um ou mais dedos na interface de toque. Uma tela touch pode detectar somente eventos acionados por um dedo. Uma tela sem toque não detecta eventos de toque.|touch, multitouch, sem toque|
|`hw.sdCard`|**Suporte para cartão SD** &ndash; determina se o dispositivo emulado dá suporte à inserção e remoção de cartões SD (Secure Digital) virtuais. O emulador usa imagens de disco montável armazenadas no computador de desenvolvimento para simular as partições de dispositivos de cartão SD reais (consulte hw.sdCard.path).|sim, não|
|`sdcard.size`|**Tamanho do cartão SD** &ndash; especifica o tamanho do arquivo do cartão SD virtual no local especificado por `hw.sdCard.path`. disponível no dispositivo (em bytes). Se o valor for um inteiro, ele especificará o tamanho em bytes. Também é possível especificar o tamanho em quilobytes, megabytes e gigabytes acrescentando **K**, **M** ou **G** ao valor. O tamanho mínimo é **de 9M** e o tamanho máximo é **1023G**.||
|`hw.sdCard.path`|**Caminho da imagem do cartão SD** &ndash; especifica o nome de arquivo e o caminho para um arquivo de imagem de partição de cartão SD no computador de desenvolvimento. Por exemplo, esse caminho pode ser definido como **C:\sd\sdcard.img** no Windows.||
|`hw.sensors.magnetic_field`|**Sensor de campo magnético** &ndash; determina se o dispositivo emulado dá suporte a um sensor de campo magnético. O sensor de campo magnético (também conhecido como magnetômetro) informa o campo geomagnético do ambiente, conforme medido ao longo de três eixos de sensor. Habilite essa configuração para aplicativos que precisam acessar uma leitura de bússola. Por exemplo, um aplicativo de navegação pode usar esse sensor para detectar a direção que o usuário está seguindo.|sim, não|
|`hw.sensors.orientation`|**Sensor de orientação** &ndash; determina se o dispositivo emulado fornece valores de sensor de orientação. O sensor de orientação mede os graus de rotação de um dispositivo ao redor de todas os três eixos físicos (x, y, z). Observe que o sensor de orientação foi preterido a partir do Android 2.2 (nível da API 8).|sim, não|
|`hw.sensors.proximity`|**Sensor de proximidade** &ndash; determina se o dispositivo emulado dá suporte a um sensor de proximidade. Esse sensor mede a proximidade de um objeto em relação à tela de exibição de um dispositivo. Normalmente, é usado para determinar se um aparelho está próximo ao ouvido de uma pessoa.|sim, não|
|`hw.sensors.temperature`|**Sensor de temperatura** &ndash; determina se o dispositivo emulado dá suporte a um sensor de temperatura. Esse sensor mede a temperatura do dispositivo em graus Celsius (&deg;C).|sim, não|
|`hw.touchScreen`|**Suporte para tela touch** &ndash; determina se o dispositivo emulado dá suporte a uma tela touch. A tela touch é usada para manipulação direta dos objetos na tela.|sim, não|
|`hw.trackBall`|**Suporte para trackball** &ndash; determina se o dispositivo emulado dá suporte a um trackball.|sim, não|
|`hw.useext4`|**Suporte para o sistema de arquivos EXT4** &ndash; determina se o dispositivo emulado usa o sistema de arquivos Linux EXT4 para partições. Como agora o tipo de sistema de arquivos é detectado automaticamente, essa opção é preterida e ignorada.|não|
|`kernel.newDeviceNaming`|**Nomenclatura do novo dispositivo kernel** &ndash; usada para especificar se o kernel exige um esquema de nomeação de dispositivo novo. Normalmente, é usado com kernels do Linux 3.10 ou posterior. Se definido como **detecção automática**, o emulador detectará automaticamente se o kernel exige um esquema de nomeação de dispositivo novo.|detecção automática, sim, não|
|`kernel.parameters`|**Parâmetros de kernel** &ndash; especifica a cadeia de caracteres de parâmetros de inicialização de kernel do Linux. Por padrão, essa configuração é deixada em branco.||
|`kernel.path`|**Caminho do kernel** &ndash; especifica o caminho para o kernel do Linux. Se esse caminho não estiver especificado, o emulador pesquisará no diretório do sistema do emulador por kernel-ranchu.||
|`kernel.supportsYaffs2`|**Suporte para partição YAFFS2** &ndash; determina se o kernel oferece suporte a partições YAFFS2 (Yet Another Flash File System 2). Normalmente, isso se aplica somente aos kernels anteriores ao Linux 3.10. Se definido como **detecção automática**, o emulador detectará automaticamente se o kernel pode montar sistemas de arquivos YAFFS2.|detecção automática, sim, não|
|`skin.name`|**Nome de capa** &ndash; o nome de uma capa de Android Emulator. Uma capa é uma coleção de arquivos que define o visual e os elementos de controle de uma exibição de emulador. Ela descreve a aparência da janela do AVD no computador de desenvolvimento. Uma capa descreve o tamanho de tela, os botões e o design geral, mas não afeta a operação do aplicativo.||
|`skin.path`|**Caminho de capa** &ndash; caminho para o diretório que contém os arquivos de aparências do emulador especificados em skin.name. Esse diretório contém arquivos de layout hardware.ini e arquivos de imagem para os elementos de exibição da capa.||
|`skin.dynamic`|**Dinâmica de capa** &ndash; se a capa é dinâmica ou não. A capa do emulador é uma capa dinâmica se o emulador criar uma capa de um determinado tamanho com base na altura e largura especificada.|não|
